using KeyboardHookReceiver.Dto;
using KeyboardHookReceiver.Models;
using Microsoft.AspNetCore.Mvc;
using Npgsql;

namespace KeyboardHookReceiver.Repository;

public class Repository : IRepository
{
    private static readonly NpgsqlConnection _conn = new("Server=localhost;" +
                                                         "Port=5432;" +
                                                         "Database=actions;" +
                                                         "User Id=postgres;" +
                                                         "Password=postgres");

    private static async Task CreateDatabaseAsync()
    {
        await _conn.OpenAsync();

        await using var cmd = new NpgsqlCommand
        {
            Connection = _conn,
            CommandText = "SELECT 1 FROM pg_database WHERE datname = 'actions'"
        };

        var db = await cmd.ExecuteScalarAsync();

        if ((int)db! != 1)
        {
            await new NpgsqlCommand
                {
                    Connection = _conn,
                    CommandText = "CREATE DATABASE Actions"
                }
                .ExecuteNonQueryAsync();
        }

        await _conn.CloseAsync();
    }

    public async Task CreateTableByAccountNameAsync(string accountName)
    {
        await CreateDatabaseAsync();

        await _conn.OpenAsync();

        await using var cmd = new NpgsqlCommand
        {
            Connection = _conn,
            CommandText =
                $"CREATE TABLE IF NOT EXISTS {accountName} " +
                "(id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, " +
                "datetime timestamp," +
                "program varchar," +
                "keyCode smallint," +
                "click varchar(30))"
        };

        await cmd.ExecuteNonQueryAsync();

        await _conn.CloseAsync();
    }

    public async Task AddKeyboardActionAsync(KeyboardActionDto log)
    {
        await CreateTableByAccountNameAsync(log.AccountName);

        await _conn.OpenAsync();

        await using var cmd = new NpgsqlCommand
        {
            Connection = _conn,
            CommandText = $"INSERT INTO {log.AccountName} (datetime, program, keyCode, click) " +
                          "VALUES (@datetime, @program, @keyCode, @click)"
        };
        cmd.Parameters.AddWithValue("@datetime", log.DateTime);
        cmd.Parameters.AddWithValue("@program", log.Program);
        cmd.Parameters.AddWithValue("@keyCode", log.KeyCode);
        cmd.Parameters.AddWithValue("@click", DBNull.Value);

        await cmd.ExecuteNonQueryAsync();

        await _conn.CloseAsync();
    }


    public async Task AddMouseActionAsync(MouseClickActionDto log)
    {
        await CreateTableByAccountNameAsync(log.AccountName);

        await _conn.OpenAsync();

        await using var cmd = new NpgsqlCommand
        {
            Connection = _conn,
            CommandText = $"INSERT INTO {log.AccountName} (datetime, program, keyCode, click) " +
                          "VALUES (@datetime, @program, @keyCode, @click)"
        };
        cmd.Parameters.AddWithValue("@datetime", log.DateTime);
        cmd.Parameters.AddWithValue("@program", log.Program);
        cmd.Parameters.AddWithValue("@keyCode", DBNull.Value);
        cmd.Parameters.AddWithValue("@click", $"{log.clickSide}Click [x:{log.X}, y:{log.Y}]");

        await cmd.ExecuteNonQueryAsync();

        await _conn.CloseAsync();
    }


    public async Task<ICollection<InputAction>> GetActionsAsync(
        string accountName,
        DateTime from,
        DateTime until)
    {
        if (!await IsAccountExists(accountName))
        {
            throw new BadHttpRequestException(accountName);
        }

        await _conn.OpenAsync();

        await using var cmd = new NpgsqlCommand
        {
            Connection = _conn,
            CommandText = "SELECT * " +
                          $"FROM {accountName} a " +
                          "WHERE a.datetime BETWEEN @from AND @until"
        };
        cmd.Parameters.AddWithValue("@from", from);
        cmd.Parameters.AddWithValue("@until", until);

        var actions = new List<InputAction>();
        await using (var reader = await cmd.ExecuteReaderAsync())
        {
            while (await reader.ReadAsync())
            {
                for (var i = 0; i < reader.FieldCount - 1; i += 5)
                {
                    actions.Add(new InputAction
                    {
                        Id = reader.GetInt32(0),
                        DateTime = reader.GetDateTime(i + 1),
                        Program = reader.GetString(i + 2),
                        KeyCode = reader.IsDBNull(i + 3) ? 0 : reader.GetInt16(i + 3),
                        Click = reader.IsDBNull(i + 4) ? null : reader.GetString(i + 4)
                    });
                }
            }
        }

        await _conn.CloseAsync();

        return actions;
    }


    public async Task<ActionResult<IEnumerable<string>>> GetListenedAccountsAsync()
    {
        await _conn.OpenAsync();

        await using var cmd = new NpgsqlCommand
        {
            Connection = _conn,
            CommandText =
                "SELECT table_name " +
                "FROM information_schema.tables " +
                "WHERE table_schema='public' AND table_type='BASE TABLE'"
        };

        var accounts = new List<string>();
        await using (var reader = await cmd.ExecuteReaderAsync())
        {
            while (await reader.ReadAsync())
            {
                for (var i = 0; i < reader.FieldCount; i++)
                {
                    accounts.Add(reader.GetString(i));
                }
            }
        }

        await _conn.CloseAsync();

        return accounts;
    }

    private static async Task<bool> IsAccountExists(string accountName)
    {
        await _conn.OpenAsync();

        await using var cmd = new NpgsqlCommand
        {
            Connection = _conn,
            CommandText = "SELECT 1 FROM pg_tables WHERE tablename = @tableName"
        };
        cmd.Parameters.AddWithValue("tableName", accountName);
        var result = cmd.ExecuteScalar();

        await _conn.CloseAsync();

        return result != null;
    }
}